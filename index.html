<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HAL Web Demo</title>
  <style>
    :root {
      --bg: #f6f8fb;
      --surface: #ffffff;
      --surface-muted: #eef2f9;
      --border: #dce4f2;
      --border-strong: #cad3e3;
      --text: #101728;
      --text-muted: #5c6475;
      --accent: #2563eb;
      --accent-hover: #1d4ed8;
      --accent-soft: rgba(37, 99, 235, 0.08);
      --success: #047857;
      --info: #0f766e;
      --radius: 16px;
      --shadow: 0 28px 60px -45px rgba(15, 23, 42, 0.65);
      --transition: 0.2s ease;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.5;
    }

    h1,
    h2,
    h3 {
      font-weight: 600;
      color: var(--text);
      margin: 0;
    }

    .page {
      max-width: 1100px;
      margin: 56px auto 72px;
      padding: 0 28px;
    }

    .page-header {
      text-align: center;
      margin-bottom: 32px;
    }

    h1 {
      font-size: clamp(2rem, 2.5vw + 1.4rem, 2.75rem);
      letter-spacing: -0.01em;
    }

    .page-subtitle {
      margin-top: 8px;
      font-size: 1rem;
      color: var(--text-muted);
    }

    .layout {
      display: grid;
      gap: 28px;
    }

    .surface {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .surface__header h2 {
      font-size: 1.25rem;
    }

    .surface__description {
      margin-top: 6px;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .media {
      position: relative;
      border-radius: calc(var(--radius) - 4px);
      background: #0f172a;
      overflow: hidden;
      min-height: 300px;
      aspect-ratio: 16 / 9; /* Default, will be updated by JS */
    }

    #videoPreview,
    #keypointsCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    #videoPreview {
      object-fit: contain;
      background: #000;
    }

    #keypointsCanvas {
      pointer-events: none;
    }

    .callout {
      border: 1px solid var(--border);
      border-radius: calc(var(--radius) - 6px);
      background: var(--surface-muted);
      padding: 18px 20px;
    }

    .callout--results {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .result-placeholder {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .result-group {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    .result-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 16px;
      background: var(--surface);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .result-item[data-tone="success"] .value {
      color: var(--success);
    }

    .result-item[data-tone="info"] .value {
      color: var(--info);
    }

    .result-item .label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .result-item .value {
      font-size: 1.3rem;
      font-weight: 600;
    }

    .result-item .meta {
      font-size: 0.875rem;
      color: var(--text-muted);
    }

    .result-warning {
      border-radius: 10px;
      padding: 12px 14px;
      background: var(--accent-soft);
      color: var(--accent-hover);
      font-size: 0.9rem;
    }

    .button {
      appearance: none;
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 0 22px;
      height: 44px;
      line-height: 1;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform var(--transition), box-shadow var(--transition), background var(--transition), color var(--transition);
      background: var(--surface-muted);
      color: var(--text);
    }

    .workflow-actions {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: stretch;
    }

    .workflow-actions__primary {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
    }

    .workflow-actions__primary .button {
      flex: 1 1 220px;
      height: 52px;
      font-size: 1rem;
      border-radius: 14px;
    }

    #selectBtn.button--primary {
      box-shadow: 0 22px 40px -26px rgba(37, 99, 235, 0.75);
    }

    #uploadBtn {
      background: #111827;
      color: #fff;
    }

    #uploadBtn:hover:not(:disabled) {
      background: #0f172a;
    }

    #uploadBtn:disabled {
      background: rgba(15, 23, 42, 0.28);
      color: rgba(255, 255, 255, 0.7);
    }

    .workflow-actions__secondary {
      display: flex;
      justify-content: flex-end;
    }

    #debugBtn {
      border-color: var(--border);
      background: rgba(15, 23, 42, 0.05);
      color: var(--text-muted);
      padding: 0 18px;
      height: 44px;
    }

    #debugBtn:hover:not(:disabled),
    #debugBtn:focus-visible {
      background: rgba(15, 23, 42, 0.12);
      border-color: rgba(15, 23, 42, 0.28);
      color: var(--text);
    }

    #debugBtn:disabled {
      opacity: 0.5;
    }

    @media (max-width: 600px) {
      .workflow-actions__primary {
        flex-direction: column;
      }

      .workflow-actions__secondary {
        justify-content: center;
      }
    }

    .button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px -18px rgba(15, 23, 42, 0.55);
    }

    .button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
      box-shadow: none;
    }

    .button--primary {
      background: var(--accent);
      color: #fff;
    }

    .button--primary:hover:not(:disabled) {
      background: var(--accent-hover);
    }

    .button--ghost {
      background: transparent;
      border-color: var(--border-strong);
    }

    .button--ghost:hover:not(:disabled) {
      color: var(--accent);
      border-color: var(--accent);
    }

    .select-wrapper {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 220px;
    }

    .select-label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    select {
      width: 100%;
      height: 44px;
      padding: 0 14px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--surface-muted);
      color: var(--text);
      font-size: 0.95rem;
      transition: border-color var(--transition), box-shadow var(--transition);
    }

    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.25);
      outline: none;
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .model-status {
      display: grid;
      gap: 10px;
      margin-top: 10px;
    }

    .model-status__item {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface-muted);
      color: inherit;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 12px 14px;
      width: 100%;
      text-align: left;
      font: inherit;
      cursor: pointer;
      transition: border-color var(--transition), background var(--transition), box-shadow var(--transition);
    }

    .model-status__item:hover,
    .model-status__item:focus-visible {
      border-color: var(--accent);
      box-shadow: 0 8px 20px -18px rgba(15, 23, 42, 0.45);
      outline: none;
    }

    .model-status__item[aria-checked="true"] {
      border-color: var(--accent);
      background: rgba(37, 99, 235, 0.08);
    }

    .model-status__main {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 600;
    }

    .model-status__meta {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .status-indicator {
      width: 11px;
      height: 11px;
      border-radius: 50%;
      background: var(--border-strong);
      box-shadow: 0 0 0 3px rgba(148, 163, 184, 0.25);
    }

    .status-indicator--online {
      background: #16a34a;
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.25);
    }

    .status-indicator--offline {
      background: #dc2626;
      box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.25);
    }

    .model-status__placeholder {
      padding: 14px 16px;
      border: 1px dashed var(--border);
      border-radius: 12px;
      background: var(--surface-muted);
      color: var(--text-muted);
      font-size: 0.9rem;
      text-align: center;
    }

    .model-status__placeholder--error {
      border-color: rgba(248, 113, 113, 0.6);
      color: #b91c1c;
    }

    .model-status__meta strong {
      font-weight: 600;
      color: var(--text);
    }

    .model-status__item[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
      pointer-events: none;
    }

    .model-status__placeholder--error {
      border-color: rgba(248, 113, 113, 0.6);
      color: #b91c1c;
    }

    input[type="file"] {
      display: none;
    }

    input[type="password"] {
      width: 100%;
      height: 44px;
      padding: 0 14px;
      border: 1px solid var(--border-strong);
      border-radius: 10px;
      background: var(--surface-muted);
      font-size: 1rem;
      transition: border-color var(--transition), box-shadow var(--transition);
    }

    input[type="password"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.25);
      outline: none;
    }

    .status-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .status-block {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 18px;
      background: var(--surface-muted);
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 122px;
    }

    .status-block h3 {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .status-copy {
      font-size: 0.95rem;
      color: var(--text);
      white-space: pre-line;
    }

    .surface--logs {
      margin-top: 28px;
    }

    #logsContent {
      border: 1px solid var(--border);
      border-radius: calc(var(--radius) - 6px);
      padding: 16px;
      background: var(--surface-muted);
      font-family: 'JetBrains Mono', 'Fira Code', 'SFMono-Regular', Menlo, monospace;
      font-size: 0.85rem;
      color: var(--text-muted);
      white-space: pre-wrap;
      overflow-y: auto;
      max-height: 280px;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      background: rgba(15, 23, 42, 0.55);
      z-index: 10;
    }

    .modal__content {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      width: min(420px, 100%);
      padding: 32px 30px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      text-align: center;
    }

    .modal__title {
      font-size: 1.4rem;
    }

    .modal__hint {
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .modal__actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      margin-top: 10px;
    }

    .modal__actions .button {
      width: 100%;
      height: 48px;
      border-radius: 12px;
      font-size: 1rem;
    }

    .modal__actions .button--ghost {
      border-color: transparent;
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-muted);
    }

    .modal__actions .button--ghost:hover {
      color: var(--text);
      background: rgba(148, 163, 184, 0.2);
    }

    @media (max-width: 540px) {
      .page {
        padding: 0 18px;
      }

      .surface {
        padding: 20px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .button {
        transition: none;
      }

      select:focus,
      input[type="password"]:focus {
        box-shadow: none;
      }
    }
  </style>
</head>

<body>
  <div class="page">
    <header class="page-header">
      <h1>HAL Web Demo</h1>
      <p class="page-subtitle">Upload or debug a video and review inference results in real time.</p>
    </header>

    <div class="modal" id="apiKeyModel" role="dialog" aria-modal="true" aria-labelledby="apiKeyModalTitle">
      <div class="modal__content" id="apiKeyModelContent">
        <h2 class="modal__title" id="apiKeyModalTitle">Enter API Key</h2>
        <p class="modal__hint">Provide your HAL API key or switch to offline debug mode.</p>
        <input type="password" id="apiKeyInput" placeholder="API Key" aria-label="API Key" />
        <div class="modal__actions">
          <button class="button button--primary" id="submitApiKeyBtn" type="button">Submit</button>
          <button class="button button--ghost" id="offlineModeBtn" type="button">Offline Debug Mode</button>
        </div>
      </div>
    </div>

    <main class="layout" aria-live="polite">
      <section class="surface" id="resultsPanel" aria-labelledby="videoPanelTitle">
        <div class="surface__header">
          <h2 id="videoPanelTitle">Live Video Preview</h2>
          <p class="surface__description">Video playback updates automatically when inference data arrives.</p>
        </div>
        <div id="videoContainer" class="media">
          <video id="videoPreview" autoplay muted playsinline webkit-playsinline></video>
          <canvas id="keypointsCanvas"></canvas>
        </div>
        <div id="inferenceResults" class="callout callout--results">
          <div class="result-placeholder">No inference data available.</div>
        </div>
      </section>

      <section class="surface surface--workflow" aria-labelledby="workflowTitle">
        <div class="surface__header">
          <h2 id="workflowTitle">Workflow</h2>
          <p class="surface__description">Select a video, run a debug pass, or push to AWS for full inference.</p>
        </div>
        <div class="workflow-actions">
          <div class="workflow-actions__primary">
            <button id="selectBtn" class="button button--primary" type="button">Select Video</button>
            <button id="uploadBtn" class="button button--primary" type="button" disabled>Upload to AWS</button>
          </div>
          <div class="workflow-actions__secondary">
            <button id="debugBtn" class="button button--ghost" type="button" disabled>Debug Test</button>
          </div>
          <input type="file" id="fileSelectInput" accept="video/*" />
        </div>
        <label class="select-wrapper visually-hidden">
          <span class="select-label">API Version</span>
          <select id="versionSelect" aria-describedby="modelStatusList"></select>
        </label>
        <div id="modelStatusList" class="model-status" aria-live="polite" role="radiogroup"
          aria-label="Available models"></div>
        <div class="status-grid">
          <div class="status-block" id="uploadPanel">
            <h3>Upload</h3>
            <p id="uploadMessage" class="status-copy">Waiting for video...</p>
          </div>
          <div class="status-block" id="statusPanel">
            <h3>Status</h3>
            <p id="statusMessage" class="status-copy">No updates yet.</p>
          </div>
          <div class="status-block" id="downloadPanel">
            <h3>Download</h3>
            <p id="downloadMessage" class="status-copy">Waiting...</p>
          </div>
        </div>
      </section>
    </main>

    <section class="surface surface--logs" id="apiLogs" aria-labelledby="logsTitle">
      <div class="surface__header">
        <h2 id="logsTitle">Live API Logs</h2>
      </div>
      <pre id="logsContent">Logs will appear here...</pre>
    </section>
  </div>

  <script>
    /* ------------------------------------------------------------------------
       App State & Configuration
    ------------------------------------------------------------------------ */
    const API_BASE_URL = 'https://ue7v1pazxb.execute-api.us-west-2.amazonaws.com';
    const OFFLINE_MODE_KEY = '__HAL_OFFLINE_DEBUG__';
    const DEBUG_GUIDES_ENABLED = false; // Toggle calibration overlay helpers
    const DEBUG_COORD_LOGS_ENABLED = false; // Toggle verbose frame logging
    const DEFAULT_ENDPOINTS = [
      { version: '0.6.0', endpoint_status: 'Offline', num_endpoint_instances: 0 },
      { version: '0.5.1', endpoint_status: 'Offline', num_endpoint_instances: 0 },
      { version: '0.4.3', endpoint_status: 'Offline', num_endpoint_instances: 0 },
      { version: '0.4.2', endpoint_status: 'Offline', num_endpoint_instances: 0 },
      { version: '0.3.3', endpoint_status: 'Offline', num_endpoint_instances: 0 }
    ];

    let API_KEY = null;
    let selectedVideoBlob = null;
    let poseData = {};
    let poseKeys = [];
    let isRenderLoopAttached = false;
    let lastDrawnFrame = null;
    let poseKeysMissingLogged = false;
    let poseFrameMissingLogged = false;
    let availableModels = [];
    let videoMetadata = { width: null, height: null, fps: 30, totalFrames: null };

    /* ------------------------------------------------------------------------
       DOM References
    ------------------------------------------------------------------------ */
    const apiKeyModel = document.getElementById('apiKeyModel');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const submitApiKeyBtn = document.getElementById('submitApiKeyBtn');
    const offlineModeBtn = document.getElementById('offlineModeBtn');

    const videoPreview = document.getElementById('videoPreview');
    const keypointsCanvas = document.getElementById('keypointsCanvas');

    const fileSelectInput = document.getElementById('fileSelectInput');

    const selectBtn = document.getElementById('selectBtn');
    const debugBtn = document.getElementById('debugBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const versionSelect = document.getElementById('versionSelect');

    const uploadMessage = document.getElementById('uploadMessage');
    const statusMessage = document.getElementById('statusMessage');
    const downloadMessage = document.getElementById('downloadMessage');
    const inferenceResults = document.getElementById('inferenceResults');
    const logsContent = document.getElementById('logsContent');
    const modelStatusList = document.getElementById('modelStatusList');

    /* ------------------------------------------------------------------------
       UI Helpers
    ------------------------------------------------------------------------ */

    function showInferencePlaceholder(message = 'No inference data yet.') {
      inferenceResults.innerHTML = `<div class="result-placeholder">${message}</div>`;
    }

    function setActionAvailability({ select, debug, upload } = {}) {
      if (typeof select === 'boolean') {
        selectBtn.disabled = !select;
      }
      if (typeof debug === 'boolean') {
        debugBtn.disabled = !debug;
      }
      if (typeof upload === 'boolean') {
        uploadBtn.disabled = !upload;
      }
    }

    function refreshActionAvailability() {
      setActionAvailability({
        select: true,
        debug: Boolean(selectedVideoBlob),
        upload: Boolean(selectedVideoBlob) && API_KEY !== OFFLINE_MODE_KEY
      });
    }

    function logToAPI(message) {
      const timestamp = new Date().toLocaleTimeString();
      logsContent.textContent += `[${timestamp}] ${message}\n`;
      logsContent.scrollTop = logsContent.scrollHeight;
      console.log(`[${timestamp}] ${message}`);
    }

    function populateVersionSelect(endpoints, { offline = false } = {}) {
      if (!Array.isArray(endpoints) || endpoints.length === 0) {
        availableModels = [];
        versionSelect.innerHTML = '';
        versionSelect.disabled = true;
        renderModelStatus([], { offline });
        return null;
      }

      availableModels = endpoints.map((endpoint) => ({
        version: endpoint.version,
        status: offline ? 'Offline' : endpoint.endpoint_status || 'Unknown',
        instances: offline ? 0 : Number(endpoint.num_endpoint_instances) || 0,
        endpointName: endpoint.endpoint_name || '',
        offline
      }));

      versionSelect.innerHTML = '';
      availableModels.forEach((model) => {
        const option = document.createElement('option');
        option.value = model.version;
        option.textContent = model.version;
        versionSelect.appendChild(option);
      });

      versionSelect.disabled = false;
      const preferred = availableModels.find((model) => !model.offline && model.status === 'InService' && model.instances > 0) || availableModels[0];

      if (preferred) {
        setSelectedVersion(preferred.version, { programmatic: true });
        return preferred.version;
      }

      renderModelStatus(availableModels, { offline });
      return null;
    }

    function renderModelStatus(models, { offline = false, loading = false } = {}) {
      if (loading) {
        modelStatusList.innerHTML = '<div class="model-status__placeholder">Loading available models...</div>';
        return;
      }

      if (!models.length) {
        modelStatusList.innerHTML = '<div class="model-status__placeholder">No models available.</div>';
        return;
      }

      const currentValue = versionSelect.value;
      const offlineMode = offline || models.every((model) => model.offline);

      modelStatusList.innerHTML = models.map((model) => {
        const isSelected = model.version === currentValue;
        const hasInstances = !offlineMode && model.status === 'InService' && model.instances > 0;
        const indicatorClass = hasInstances ? 'status-indicator status-indicator--online' : 'status-indicator status-indicator--offline';
        const metaLabel = offlineMode
          ? 'Debug mode only'
          : hasInstances
            ? formatInstanceLabel(model.instances)
            : 'No active instances';
        const statusSuffix = offlineMode ? '' : model.status ? ` · ${model.status}` : '';
        const ariaStatus = offlineMode ? 'offline mode' : (model.status || 'status unknown');
        const ariaMeta = offlineMode
          ? 'Debug mode only'
          : hasInstances
            ? `${model.instances} active ${model.instances === 1 ? 'instance' : 'instances'}`
            : 'No active instances';
        const ariaLabel = `${model.version}: ${ariaMeta}, ${ariaStatus}`;

        return `
          <button
            type="button"
            class="model-status__item"
            data-version="${model.version}"
            role="radio"
            aria-checked="${isSelected}"
            tabindex="${isSelected ? '0' : '-1'}"
            aria-label="${ariaLabel}"
          >
            <span class="model-status__main">
              <span class="${indicatorClass}" aria-hidden="true"></span>
              <span>${model.version}</span>
            </span>
            <span class="model-status__meta">${metaLabel}${statusSuffix}</span>
          </button>
        `.trim();
      }).join('');
    }

    function formatInstanceLabel(count) {
      if (!Number.isFinite(count) || count <= 0) {
        return 'No active instances';
      }
      return `${count} active ${count === 1 ? 'instance' : 'instances'}`;
    }

    function setSelectedVersion(version, { programmatic = false } = {}) {
      if (!version || !availableModels.length) {
        return;
      }

      const optionExists = Array.from(versionSelect.options).some((option) => option.value === version);
      if (!optionExists) {
        return;
      }

      const previousValue = versionSelect.value;
      if (previousValue !== version) {
        versionSelect.value = version;
      }

      handleVersionChange();

      if (!programmatic) {
        requestAnimationFrame(() => {
          const nextItem = modelStatusList.querySelector(`.model-status__item[data-version="${version}"]`);
          if (nextItem) {
            nextItem.focus();
          }
        });
      }
    }

    showInferencePlaceholder('No inference data available.');
    setActionAvailability({ select: false, debug: false, upload: false });
    populateVersionSelect(DEFAULT_ENDPOINTS, { offline: true });
    resolveCanvasMetrics();

    /* ------------------------------------------------------------------------
       Event Wiring
    ------------------------------------------------------------------------ */
    submitApiKeyBtn.addEventListener('click', handleApiKeySubmit);
    offlineModeBtn.addEventListener('click', enableOfflineMode);
    selectBtn.addEventListener('click', () => fileSelectInput.click());
    fileSelectInput.addEventListener('change', handleFileInputChange);
    uploadBtn.addEventListener('click', handleUploadClick);
    debugBtn.addEventListener('click', handleDebugClick);
    versionSelect.addEventListener('change', () => setSelectedVersion(versionSelect.value, { programmatic: true }));
    modelStatusList.addEventListener('click', handleModelSelectionClick);
    modelStatusList.addEventListener('keydown', handleModelStatusKeydown);
    window.addEventListener('resize', resolveCanvasMetrics);

    /* ------------------------------------------------------------------------
       Event Handlers
    ------------------------------------------------------------------------ */
    function handleApiKeySubmit() {
      const enteredKey = apiKeyInput.value.trim();
      if (!enteredKey) {
        alert('API key is required to proceed.');
        return;
      }

      API_KEY = enteredKey;
      apiKeyModel.style.display = 'none';
      initializeApp(false);
    }

    function enableOfflineMode() {
      API_KEY = OFFLINE_MODE_KEY;
      apiKeyModel.style.display = 'none';
      initializeApp(true);
    }

    function handleFileInputChange(event) {
      const [file] = event.target.files || [];
      if (file) {
        handleFileSelection(file);
        fileSelectInput.value = '';
      }
    }

    function handleModelSelectionClick(event) {
      const target = event.target.closest('.model-status__item');
      if (!target || !modelStatusList.contains(target) || target.hasAttribute('disabled')) {
        return;
      }

      const { version } = target.dataset;
      if (version) {
        setSelectedVersion(version);
      }
    }

    function handleModelStatusKeydown(event) {
      if (!event.target.classList.contains('model-status__item')) {
        return;
      }

      const actionableKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
      if (!actionableKeys.includes(event.key)) {
        return;
      }

      const items = Array.from(modelStatusList.querySelectorAll('.model-status__item'));
      if (items.length === 0) {
        return;
      }

      const currentIndex = items.findIndex((item) => item.dataset.version === event.target.dataset.version);
      if (currentIndex === -1) {
        return;
      }

      event.preventDefault();

      let nextIndex = currentIndex;
      switch (event.key) {
        case 'ArrowUp':
        case 'ArrowLeft':
          nextIndex = currentIndex === 0 ? items.length - 1 : currentIndex - 1;
          break;
        case 'ArrowDown':
        case 'ArrowRight':
          nextIndex = currentIndex === items.length - 1 ? 0 : currentIndex + 1;
          break;
        case 'Home':
          nextIndex = 0;
          break;
        case 'End':
          nextIndex = items.length - 1;
          break;
        default:
          break;
      }

      const nextItem = items[nextIndex];
      if (nextItem && nextItem.dataset.version) {
        setSelectedVersion(nextItem.dataset.version);
      }
    }

    function handleVersionChange() {
      if (!availableModels.length) {
        return;
      }
      const offlineMode = API_KEY === OFFLINE_MODE_KEY || availableModels.every((model) => model.offline);
      renderModelStatus(availableModels, { offline: offlineMode });
    }

    async function handleUploadClick() {
      if (!selectedVideoBlob) {
        uploadMessage.textContent = 'No video selected!';
        logToAPI('Upload attempted without a video.');
        return;
      }

      setActionAvailability({ select: false, debug: false, upload: false });
      uploadMessage.textContent = 'Starting upload…';
      statusMessage.textContent = 'Uploading video…';
      downloadMessage.textContent = 'Awaiting processing…';
      showInferencePlaceholder('Waiting for inference results...');
      logToAPI('Upload process started.');

      const timestamp = new Date().toISOString().replace(/[-:.TZ]/g, '');
      const videoName = `web_upload_${timestamp}.mp4`;
      logToAPI(`Uploading video as: ${videoName}`);

      try {
        const uploadEndpoint = `${API_BASE_URL}/upload/dev/${encodeURIComponent(videoName)}`;
        logToAPI(`Requesting upload URL: ${uploadEndpoint}`);

        const uploadResponse = await fetch(uploadEndpoint, {
          method: 'GET',
          headers: {
            'x-api-version': versionSelect.value,
            'x-api-key': API_KEY
          }
        });

        if (!uploadResponse.ok) {
          throw new Error(`Upload request failed: ${uploadResponse.status} ${uploadResponse.statusText}`);
        }

        const uploadData = await uploadResponse.json();
        const { guid, presigned_url: presignedUrl } = uploadData;
        logToAPI(`Upload details: GUID=${guid}, URL=${presignedUrl}`);
        uploadMessage.textContent = `Video GUID ${guid}`;
        logToAPI(`Uploading video to: ${presignedUrl}`);
        const putResponse = await fetch(presignedUrl, {
          method: 'PUT',
          headers: { 'Content-Type': 'video/mp4' },
          body: selectedVideoBlob
        });

        if (!putResponse.ok) {
          throw new Error(`Upload failed: ${putResponse.status} ${putResponse.statusText}`);
        }

        uploadMessage.textContent = 'Upload complete.';
        logToAPI('Video uploaded to AWS.');

        statusMessage.textContent = 'Processing started…';
        logToAPI('Starting status polling.');
        pollStatus(guid);
      } catch (error) {
        uploadMessage.textContent += `\nError: ${error.message}`;
        logToAPI(`Upload error: ${error.message}`);
        refreshActionAvailability();
      }
    }

    function handleDebugClick() {
      if (!selectedVideoBlob) {
        alert('Please select a video first.');
        return;
      }

      setActionAvailability({ select: false, debug: false, upload: false });
      logToAPI('Debug test triggered.');
      uploadMessage.textContent = 'Debug mode active, upload skipped.';
      statusMessage.textContent = 'Simulating processing…';
      downloadMessage.textContent = 'Loading debug JSON…';
      showInferencePlaceholder('Waiting for debug results...');

      const debugJson = {
        version: versionSelect.value,
        status: 'success',
        message: 'Debug inference completed successfully',
        warnings: [],
        video_metadata: {
          fps: 29.565029565029565,
          total_frames: 730,
          width: 1440,
          height: 1080
        },
        subjects: [
          {
            subject_id: 0,
            track_id: 1,
            left_prediction: 3,
            left_confidence: 0.74,
            right_prediction: 2,
            right_confidence: 0.78,
            track_length: 20,
            pose_keys: ['Box_X1','Box_Y1','Box_X2','Box_Y2','X_left_shoulder','Y_left_shoulder','X_right_shoulder','Y_right_shoulder','X_left_elbow','Y_left_elbow','X_right_elbow','Y_right_elbow','X_left_wrist','Y_left_wrist','X_right_wrist','Y_right_wrist'],
            pose_df: {
              "0": [262,0,629,1077,315,186,474,232,363,398,567,463,533,380,610,402],
              "1": [275,0,647,1077,323,185,486,230,379,394,575,458,551,366,618,388],
              "2": [287,0,664,1077,331,183,497,228,395,389,582,453,568,353,627,374],
              "3": [299,0,679,1077,340,181,507,225,409,385,589,448,583,341,635,362],
              "4": [309,0,692,1077,348,179,515,221,422,380,596,442,597,331,642,350],
              "5": [319,0,704,1077,357,175,521,217,432,375,603,436,608,322,649,339],
              "6": [327,0,712,1077,366,172,526,213,441,369,609,430,617,313,656,330],
              "7": [333,0,718,1077,374,168,529,208,448,364,614,424,623,307,661,323],
              "8": [338,0,721,1077,380,164,532,205,452,359,619,419,626,302,665,318],
              "9": [342,1,721,1077,385,162,533,202,455,357,622,417,627,301,667,317],
              "10": [344,1,717,1077,389,161,533,202,457,356,623,416,626,304,668,320],
              "11": [345,2,712,1077,391,162,533,203,457,360,622,418,624,313,667,328],
              "12": [346,2,705,1078,392,164,533,206,458,366,620,424,621,326,665,341],
              "13": [347,2,699,1079,394,168,531,210,457,375,617,432,618,342,663,357],
              "14": [349,3,694,1079,396,173,530,215,457,385,614,443,615,360,662,376],
              "15": [351,3,690,1080,398,178,527,220,457,396,611,455,613,379,661,395],
              "16": [354,3,689,1080,401,183,525,226,457,407,608,468,611,396,661,413],
              "17": [359,2,688,1080,406,187,522,231,457,416,605,482,609,412,662,430],
              "18": [364,2,688,1080,411,190,520,237,456,424,601,494,607,425,663,444],
              "19": [370,1,688,1080,417,192,518,241,456,430,596,505,605,437,663,457],
              "20": [377,1,687,1080,422,194,517,245,455,435,589,515,602,447,663,468],
              "21": [383,1,687,1079,428,196,516,249,454,439,580,524,598,456,662,478],
              "22": [389,0,687,1079,434,197,517,252,454,441,568,532,596,462,661,487],
              "23": [394,0,688,1079,441,199,517,255,457,442,555,539,595,465,658,496],
              "24": [398,0,693,1078,449,200,518,258,463,440,541,545,599,464,655,505],
              "25": [402,0,702,1078,459,202,518,262,475,435,527,551,608,457,652,513],
              "26": [404,0,719,1078,471,205,516,265,493,427,513,557,625,445,649,520],
              "27": [406,0,743,1078,486,207,513,269,518,417,500,563,649,429,646,528],
              "28": [406,0,775,1078,503,210,507,273,549,404,488,569,682,410,643,534],
              "29": [405,0,814,1078,521,211,500,276,584,389,478,575,721,389,640,542]
            }
          }
        ]
      };

      setTimeout(() => {
        applyInferenceResult(debugJson, 'Debug');
      }, 500);
      
    }

    /* ------------------------------------------------------------------------
       Initialization & API helpers
    ------------------------------------------------------------------------ */
    function initializeApp(isOffline) {
      selectedVideoBlob = null;
      poseData = {};
      poseKeys = [];
      availableModels = [];
      videoMetadata = { width: null, height: null, fps: 30, totalFrames: null };

      videoPreview.pause();
      videoPreview.removeAttribute('src');
      videoPreview.load();
      const resetCtx = keypointsCanvas.getContext('2d');
      if (resetCtx) {
        resetCtx.setTransform(1, 0, 0, 1, 0, 0);
        resetCtx.clearRect(0, 0, keypointsCanvas.width, keypointsCanvas.height);
      }
      resolveCanvasMetrics();

      refreshActionAvailability();

      if (isOffline) {
        populateVersionSelect(DEFAULT_ENDPOINTS, { offline: true });
        uploadMessage.textContent = 'Offline debug mode. Select a video to test locally.';
        logToAPI('Offline debug mode enabled. Uploads to AWS are disabled.');
        versionSelect.disabled = false;
      } else {
        versionSelect.disabled = true;
        versionSelect.innerHTML = '';
        renderModelStatus([], { loading: true });
        uploadMessage.textContent = 'API key saved. Select a video to begin.';
        logToAPI('API key set. Fetching available versions...');
        fetchHealthStatus();
      }

      statusMessage.textContent = 'No updates yet.';
      downloadMessage.textContent = 'Waiting...';
      showInferencePlaceholder('Select a video to get started.');
    }

    async function fetchHealthStatus() {
      if (API_KEY === OFFLINE_MODE_KEY) {
        uploadMessage.textContent = 'Offline mode: uploads are disabled. Switch to online mode with an API key to upload.';
        logToAPI('Upload blocked: offline mode active.');
        return;
      }

      const healthEndpoint = `${API_BASE_URL}/health`;
      renderModelStatus([], { loading: true });
      versionSelect.disabled = true;

      try {
        const res = await fetch(healthEndpoint, {
          headers: { 'x-api-key': API_KEY }
        });

        if (!res.ok) {
          throw new Error(`Health request failed: ${res.status} ${res.statusText}`);
        }

        const healthData = await res.json();
        const endpoints = Array.isArray(healthData.endpoints) ? healthData.endpoints : [];
        const inService = endpoints.filter((endpoint) => endpoint.endpoint_status === 'InService');
        const candidates = inService.length > 0 ? inService : endpoints;

        if (candidates.length === 0) {
          availableModels = [];
          versionSelect.innerHTML = '';
          renderModelStatus([], { offline: false });
          versionSelect.disabled = true;
          logToAPI('Health check returned no available endpoints.');
          return;
        }

        candidates.sort((a, b) => b.version.localeCompare(a.version, undefined, { numeric: true, sensitivity: 'base' }));
        const defaultVersion = populateVersionSelect(candidates, { offline: false });
        const versionsList = availableModels.map((model) => model.version).join(', ');
        const message = defaultVersion
          ? `Available versions: ${versionsList}. Defaulting to ${defaultVersion}.`
          : `Available versions: ${versionsList}.`;
        logToAPI(message);
      } catch (error) {
        logToAPI(`Health check error: ${error.message}`);
        renderModelStatus(availableModels, { offline: API_KEY === OFFLINE_MODE_KEY });
        versionSelect.disabled = availableModels.length === 0;
      }
    }

    function handleFileSelection(file) {
      selectedVideoBlob = file;
      uploadMessage.textContent = `Selected: ${file.name} (${file.size} bytes). Ready for upload or debug.`;
      statusMessage.textContent = 'Video file selected.';
      downloadMessage.textContent = 'Waiting...';
      showInferencePlaceholder('Awaiting inference results.');
      logToAPI(`Video selected: ${file.name}`);

      const videoURL = URL.createObjectURL(file);
      videoPreview.srcObject = null;
      videoPreview.src = videoURL;
      videoPreview.controls = true;
      videoPreview.onloadedmetadata = () => {
        const aspectRatio = `${videoPreview.videoWidth} / ${videoPreview.videoHeight}`;
        document.getElementById('videoContainer').style.aspectRatio = aspectRatio;
        resolveCanvasMetrics();
        logToAPI(`Video metadata loaded: ${videoPreview.videoWidth}x${videoPreview.videoHeight}, duration ${videoPreview.duration.toFixed(2)}s.`);
      };

      refreshActionAvailability();

      if (API_KEY === OFFLINE_MODE_KEY) {
        uploadMessage.textContent += '\nOffline mode: Upload button remains disabled.';
      }
    }

    /* ------------------------------------------------------------------------
       Upload & Polling Flow
    ------------------------------------------------------------------------ */
    function pollStatus(guid) {
      let pollCount = 0;
      const maxPolls = 60;
      const intervalTime = 30000;
      logToAPI(`Polling status for GUID: ${guid}`);

      const pollTimer = setInterval(async () => {
        pollCount += 1;
        logToAPI(`Polling attempt #${pollCount}`);
        statusMessage.textContent = `Status check ${pollCount}`;

        try {
          const statusEndpoint = `${API_BASE_URL}/status/dev/${encodeURIComponent(guid)}`;
          const statusRes = await fetch(statusEndpoint, {
            method: 'GET',
            headers: { 'x-api-key': API_KEY }
          });

          if (!statusRes.ok) {
            throw new Error(`Status error: ${statusRes.status} ${statusRes.statusText}`);
          }

          const statusData = await statusRes.json();
          logToAPI(`Status: ${JSON.stringify(statusData)}`);
          statusMessage.textContent = statusData.status || 'Processing';

          if (statusData.status === 'done') {
            clearInterval(pollTimer);
            statusMessage.textContent = 'Processing complete';
            downloadMessage.textContent = 'Downloading results…';
            logToAPI('Processing complete. Fetching results.');
            fetchFinalResults(guid);
          } else if (pollCount >= maxPolls) {
            clearInterval(pollTimer);
            statusMessage.textContent = 'Processing timed out';
            downloadMessage.textContent = 'No results available.';
            logToAPI('Max polling reached.');
            refreshActionAvailability();
          }
        } catch (error) {
          statusMessage.textContent = `Polling failed`;
          logToAPI(`Polling error: ${error.message}`);
          clearInterval(pollTimer);
          refreshActionAvailability();
        }
      }, intervalTime);
    }

    async function fetchFinalResults(guid) {
      try {
        const downloadEndpoint = `${API_BASE_URL}/download/dev/${encodeURIComponent(guid)}`;
        logToAPI(`Fetching download URL: ${downloadEndpoint}`);

        const downloadRes = await fetch(downloadEndpoint, {
          method: 'GET',
          headers: { 'x-api-key': API_KEY }
        });

        if (!downloadRes.ok) {
          throw new Error(`Download request failed: ${downloadRes.status} ${downloadRes.statusText}`);
        }

        const downloadData = await downloadRes.json();
        const finalUrl = downloadData.presigned_url;
        logToAPI(`Final download URL: ${finalUrl}`);
        downloadMessage.textContent = 'Results URL received. Fetching predictions...';

        const finalRes = await fetch(finalUrl);
        if (!finalRes.ok) {
          throw new Error(`Final JSON fetch failed: ${finalRes.status} ${finalRes.statusText}`);
        }

        const finalJson = await finalRes.json();
        logToAPI(`Final payload received. version=${finalJson.version || 'n/a'}, status=${finalJson.status || 'n/a'}`);
        applyInferenceResult(finalJson, 'Inference');
      } catch (error) {
        downloadMessage.textContent = `Error: ${error.message}`;
        logToAPI(`Download error: ${error.message}`);
        refreshActionAvailability();
      }
    }

    /* ------------------------------------------------------------------------
       Result Application & Rendering
    ------------------------------------------------------------------------ */
    function applyInferenceResult(finalJson, contextLabel) {
      const label = contextLabel || 'Inference';

      if (!finalJson || typeof finalJson !== 'object') {
        downloadMessage.textContent = `${label} results unavailable.`;
        logToAPI(`${label} results missing or invalid.`);
        refreshActionAvailability();
        return;
      }

      const subject = Array.isArray(finalJson.subjects) && finalJson.subjects.length > 0
        ? finalJson.subjects[0]
        : null;

      if (!subject) {
        downloadMessage.textContent = `${label} results contain no subjects.`;
        logToAPI(`${label} results missing subject data.`);
        refreshActionAvailability();
        return;
      }

      poseData = subject.pose_df || {};
      poseKeys = subject.pose_keys || [];
      const responseMeta = finalJson.video_metadata || {};
      videoMetadata = {
        width: Number(responseMeta.width) || videoMetadata.width || null,
        height: Number(responseMeta.height) || videoMetadata.height || null,
        fps: Number(responseMeta.fps) || videoMetadata.fps || 30,
        totalFrames: Number(responseMeta.total_frames) || videoMetadata.totalFrames
      };
      if (videoMetadata.width && videoMetadata.height) {
        document.getElementById('videoContainer').style.aspectRatio = `${videoMetadata.width} / ${videoMetadata.height}`;
      }

      lastDrawnFrame = null;
      poseKeysMissingLogged = false;
      poseFrameMissingLogged = false;

      const versionUsed = finalJson.version || versionSelect.value || 'n/a';
      const rightPrediction = subject.right_prediction ?? 'N/A';
      const rightConfidence = subject.right_confidence;
      const leftPrediction = subject.left_prediction ?? 'N/A';
      const leftConfidence = subject.left_confidence;

      const formatConfidence = (value) => (typeof value === 'number' ? `${(value * 100).toFixed(0)}%` : 'N/A');

      downloadMessage.textContent = `${label} results ready (version ${versionUsed}).\nRight: HAL=${rightPrediction} (${formatConfidence(rightConfidence)})\nLeft: HAL=${leftPrediction} (${formatConfidence(leftConfidence)})`;

      if (Array.isArray(finalJson.warnings) && finalJson.warnings.length > 0) {
        downloadMessage.textContent += `\nWarnings: ${finalJson.warnings.join(' | ')}`;
      }

      let resultMarkup = `
        <div class="result-group" role="list">
          <div class="result-item" data-tone="success" role="listitem">
            <span class="label">Right Prediction</span>
            <span class="value">${rightPrediction}</span>
            <span class="meta">Confidence ${formatConfidence(rightConfidence)}</span>
          </div>
          <div class="result-item" data-tone="info" role="listitem">
            <span class="label">Left Prediction</span>
            <span class="value">${leftPrediction}</span>
            <span class="meta">Confidence ${formatConfidence(leftConfidence)}</span>
          </div>
        </div>
      `;

      if (Array.isArray(finalJson.warnings) && finalJson.warnings.length > 0) {
        resultMarkup += `<div class="result-warning">${finalJson.warnings.join(' • ')}</div>`;
      }

      inferenceResults.innerHTML = resultMarkup;

      const subjectDescriptor = `subject_id=${subject.subject_id ?? 'n/a'}, track_id=${subject.track_id ?? 'n/a'}`;
      logToAPI(`${label} results displayed (${subjectDescriptor}, version=${versionUsed}).`);

      setupCanvasRendering();

      if (videoPreview.paused || videoPreview.ended) {
        videoPreview.play().catch(() => { });
      }

      refreshActionAvailability();
    }

    /* ------------------------------------------------------------------------
       Canvas Rendering
    ------------------------------------------------------------------------ */
    function setupCanvasRendering() {
      if (Object.keys(poseData).length === 0) {
        logToAPI('No pose data available for rendering.');
        return;
      }

      resolveCanvasMetrics();

      if (!isRenderLoopAttached) {
        videoPreview.addEventListener('play', renderLoop);
        videoPreview.addEventListener('seeked', () => requestAnimationFrame(renderLoop));
        isRenderLoopAttached = true;
        logToAPI('Keypoints overlay setup complete. Render loop attached.');
      } else {
        logToAPI('Keypoints overlay data refreshed.');
      }

      if (!videoPreview.paused && !videoPreview.ended) {
        requestAnimationFrame(renderLoop);
      }
    }

    function renderLoop() {
      if (videoPreview.paused || videoPreview.ended) {
        return;
      }
      drawKeypointsOverlay();
      requestAnimationFrame(renderLoop);
    }

    function drawKeypointsOverlay() {
      const metrics = resolveCanvasMetrics();
      if (!metrics) {
        return;
      }

      const {
        ctx,
        offsetX,
        offsetY,
        renderW,
        renderH,
        poseScaleX,
        poseScaleY,
        intrinsicWidth,
        intrinsicHeight,
        poseWidth,
        poseHeight
      } = metrics;

      const toCanvasX = (value) => offsetX + value * poseScaleX;
      const toCanvasY = (value) => offsetY + value * poseScaleY;

      if (DEBUG_GUIDES_ENABLED) {
        drawCalibrationGuides(ctx, { offsetX, offsetY, renderW, renderH, intrinsicWidth, intrinsicHeight });
      }

      if (!poseKeys.length) {
        if (!poseKeysMissingLogged) {
          logToAPI('Pose keys unavailable; skipping keypoint overlay.');
          poseKeysMissingLogged = true;
        }
        return;
      }
      poseKeysMissingLogged = false;

      const currentFrame = Math.floor(videoPreview.currentTime * (videoMetadata.fps || 30));
      const framePayload = poseData[currentFrame] ?? poseData[currentFrame?.toString?.()];
      if (!Array.isArray(framePayload)) {
        if (!poseFrameMissingLogged) {
          logToAPI(`No pose data for frame ${currentFrame}.`);
          poseFrameMissingLogged = true;
        }
        return;
      }
      poseFrameMissingLogged = false;

      const frameData = {};
      poseKeys.forEach((key, index) => {
        frameData[key] = framePayload[index];
      });

      if (DEBUG_COORD_LOGS_ENABLED && currentFrame !== lastDrawnFrame) {
        console.group(`Frame ${currentFrame}`);
        console.log('Video metadata:', videoMetadata);
        console.log('Render metrics:', {
          offsetX,
          offsetY,
          renderW,
          renderH,
          poseScaleX,
          poseScaleY,
          intrinsicWidth,
          intrinsicHeight,
          poseWidth,
          poseHeight
        });
      }

      const hasBox = ['Box_X1', 'Box_Y1', 'Box_X2', 'Box_Y2'].every((key) => Number.isFinite(frameData[key]));
      if (hasBox) {
        const x1 = toCanvasX(frameData.Box_X1);
        const y1 = toCanvasY(frameData.Box_Y1);
        const x2 = toCanvasX(frameData.Box_X2);
        const y2 = toCanvasY(frameData.Box_Y2);

        if (DEBUG_COORD_LOGS_ENABLED && currentFrame !== lastDrawnFrame) {
          console.log('Box (canvas CSS px):', { x1, y1, x2, y2 });
        }

        ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
        ctx.lineWidth = 3;
        ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
      }

      const jointKeys = [
        'X_left_shoulder', 'Y_left_shoulder',
        'X_right_shoulder', 'Y_right_shoulder',
        'X_left_elbow', 'Y_left_elbow',
        'X_right_elbow', 'Y_right_elbow',
        'X_left_wrist', 'Y_left_wrist',
        'X_right_wrist', 'Y_right_wrist'
      ];

      const hasJoints = jointKeys.every((key) => Number.isFinite(frameData[key]));
      if (hasJoints) {
        const jointPairs = [
          ['left_shoulder', frameData.X_left_shoulder, frameData.Y_left_shoulder],
          ['right_shoulder', frameData.X_right_shoulder, frameData.Y_right_shoulder],
          ['left_elbow', frameData.X_left_elbow, frameData.Y_left_elbow],
          ['right_elbow', frameData.X_right_elbow, frameData.Y_right_elbow],
          ['left_wrist', frameData.X_left_wrist, frameData.Y_left_wrist],
          ['right_wrist', frameData.X_right_wrist, frameData.Y_right_wrist]
        ].map(([label, x, y]) => ({ label, x: toCanvasX(x), y: toCanvasY(y) }));

        if (DEBUG_COORD_LOGS_ENABLED && currentFrame !== lastDrawnFrame) {
          console.log('Joints (canvas CSS px):', jointPairs);
        }

        ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
        jointPairs.forEach(({ x, y }) => {
          ctx.beginPath();
          ctx.arc(x, y, 7, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(jointPairs[0].x, jointPairs[0].y);
        ctx.lineTo(jointPairs[2].x, jointPairs[2].y);
        ctx.lineTo(jointPairs[4].x, jointPairs[4].y);
        ctx.moveTo(jointPairs[1].x, jointPairs[1].y);
        ctx.lineTo(jointPairs[3].x, jointPairs[3].y);
        ctx.lineTo(jointPairs[5].x, jointPairs[5].y);
        ctx.stroke();

        // ---------------------------------------------------------
        // Draw Hand Joints (Fingers) if available (v0.6.0+)
        // ---------------------------------------------------------
        const fingers = ['thumb', 'index', 'middle', 'ring', 'pinky'];
        const handSides = [
          { side: 'left', wristIdx: 4 },
          { side: 'right', wristIdx: 5 }
        ];

        handSides.forEach(({ side, wristIdx }) => {
          const wrist = jointPairs[wristIdx];
          
          fingers.forEach((finger) => {
            const xKey = `X_${side}_${finger}_tip`;
            const yKey = `Y_${side}_${finger}_tip`;
            
            const xVal = frameData[xKey];
            const yVal = frameData[yKey];

            if (Number.isFinite(xVal) && Number.isFinite(yVal)) {
              const tipX = toCanvasX(xVal);
              const tipY = toCanvasY(yVal);

              // Draw connection from wrist to finger tip
              ctx.beginPath();
              ctx.moveTo(wrist.x, wrist.y);
              ctx.lineTo(tipX, tipY);
              ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; // Matching color scheme, slightly more transparent
              ctx.lineWidth = 2;
              ctx.stroke();

              // Draw finger tip
              ctx.beginPath();
              ctx.arc(tipX, tipY, 4, 0, Math.PI * 2);
              ctx.fillStyle = 'rgba(0, 255, 0, 0.9)'; // Matching point color
              ctx.fill();
            }
          });
        });
      }

      if (DEBUG_COORD_LOGS_ENABLED && currentFrame !== lastDrawnFrame) {
        console.groupEnd();
      }

      lastDrawnFrame = currentFrame;
    }

    function drawCalibrationGuides(ctx, metrics) {
      const { renderW, renderH, offsetX, offsetY, intrinsicWidth, intrinsicHeight } = metrics;
      if (!intrinsicWidth || !intrinsicHeight) {
        return;
      }

      const centerX = offsetX + renderW / 2;
      const centerY = offsetY + renderH / 2;

      ctx.save();

      ctx.strokeStyle = 'rgba(255, 255, 0, 0.55)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 6]);
      ctx.strokeRect(offsetX, offsetY, renderW, renderH);
      ctx.setLineDash([]);

      ctx.strokeStyle = 'rgba(236, 72, 153, 0.45)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(centerX - 24, centerY);
      ctx.lineTo(centerX + 24, centerY);
      ctx.moveTo(centerX, centerY - 24);
      ctx.lineTo(centerX, centerY + 24);
      ctx.stroke();

      ctx.fillStyle = 'rgba(96, 165, 250, 0.8)';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.font = '11px Inter, sans-serif';
      ctx.textBaseline = 'top';
      ctx.fillStyle = 'rgba(59, 130, 246, 0.85)';
      [
        { label: 'TL', x: 0, y: 0 },
        { label: 'TR', x: intrinsicWidth, y: 0 },
        { label: 'BR', x: intrinsicWidth, y: intrinsicHeight },
        { label: 'BL', x: 0, y: intrinsicHeight }
      ].forEach(({ label, x, y }) => {
        const cx = offsetX + (x / intrinsicWidth) * renderW;
        const cy = offsetY + (y / intrinsicHeight) * renderH;
        ctx.beginPath();
        ctx.arc(cx, cy, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillText(label, cx + 6, cy + 2);
      });

      const inset = 100;
      if (intrinsicWidth > inset * 2 && intrinsicHeight > inset * 2) {
        ctx.strokeStyle = 'rgba(34, 197, 94, 0.45)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(
          offsetX + (inset / intrinsicWidth) * renderW,
          offsetY + (inset / intrinsicHeight) * renderH,
          renderW - (2 * inset / intrinsicWidth) * renderW,
          renderH - (2 * inset / intrinsicHeight) * renderH
        );
        ctx.setLineDash([]);
      }

      ctx.restore();
    }

    function resolveCanvasMetrics() {
      const ctx = keypointsCanvas.getContext('2d');
      if (!ctx) {
        return null;
      }

      const dpr = window.devicePixelRatio || 1;
      const cssWidth = videoPreview.clientWidth || keypointsCanvas.clientWidth || videoMetadata.width || videoPreview.videoWidth || 0;
      const cssHeight = videoPreview.clientHeight || keypointsCanvas.clientHeight || videoMetadata.height || videoPreview.videoHeight || 0;

      if (!cssWidth || !cssHeight) {
        return null;
      }

      keypointsCanvas.style.width = `${cssWidth}px`;
      keypointsCanvas.style.height = `${cssHeight}px`;

      const requiredWidth = Math.round(cssWidth * dpr);
      const requiredHeight = Math.round(cssHeight * dpr);
      if (keypointsCanvas.width !== requiredWidth || keypointsCanvas.height !== requiredHeight) {
        keypointsCanvas.width = requiredWidth;
        keypointsCanvas.height = requiredHeight;
      }

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, keypointsCanvas.width, keypointsCanvas.height);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const intrinsicWidth = videoPreview.videoWidth || videoMetadata.width || 0;
      const intrinsicHeight = videoPreview.videoHeight || videoMetadata.height || 0;
      if (!intrinsicWidth || !intrinsicHeight) {
        return null;
      }

      const poseWidth = videoMetadata.width || intrinsicWidth;
      const poseHeight = videoMetadata.height || intrinsicHeight;

      const renderScale = Math.min(cssWidth / intrinsicWidth, cssHeight / intrinsicHeight);
      const renderW = intrinsicWidth * renderScale;
      const renderH = intrinsicHeight * renderScale;
      const offsetX = (cssWidth - renderW) / 2;
      const offsetY = (cssHeight - renderH) / 2;

      const poseScaleX = poseWidth ? renderW / poseWidth : renderScale;
      const poseScaleY = poseHeight ? renderH / poseHeight : renderScale;

      return {
        ctx,
        offsetX,
        offsetY,
        renderW,
        renderH,
        poseScaleX,
        poseScaleY,
        intrinsicWidth,
        intrinsicHeight,
        poseWidth,
        poseHeight
      };
    }
  </script>
</body>

</html>
