<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HAL Web Demo</title>
  <style>
    :root {
      --bg: #f6f8fb;
      --surface: #ffffff;
      --surface-muted: #eef2f9;
      --border: #dce4f2;
      --border-strong: #cad3e3;
      --text: #101728;
      --text-muted: #5c6475;
      --accent: #2563eb;
      --accent-hover: #1d4ed8;
      --accent-soft: rgba(37, 99, 235, 0.08);
      --success: #047857;
      --info: #0f766e;
      --radius: 16px;
      --shadow: 0 28px 60px -45px rgba(15, 23, 42, 0.65);
      --transition: 0.2s ease;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.5;
    }

    h1, h2, h3 {
      font-weight: 600;
      color: var(--text);
      margin: 0;
    }

    .page {
      max-width: 1100px;
      margin: 56px auto 72px;
      padding: 0 28px;
    }

    .page-header {
      text-align: center;
      margin-bottom: 32px;
    }

    h1 {
      font-size: clamp(2rem, 2.5vw + 1.4rem, 2.75rem);
      letter-spacing: -0.01em;
    }

    .page-subtitle {
      margin-top: 8px;
      font-size: 1rem;
      color: var(--text-muted);
    }

    .layout {
      display: grid;
      gap: 28px;
    }

    .surface {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .surface__header h2 {
      font-size: 1.25rem;
    }

    .surface__description {
      margin-top: 6px;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .media {
      position: relative;
      border-radius: calc(var(--radius) - 4px);
      background: #0f172a;
      overflow: hidden;
      min-height: 300px;
    }

    #videoPreview {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
      background: #000;
    }

    #keypointsCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .callout {
      border: 1px solid var(--border);
      border-radius: calc(var(--radius) - 6px);
      background: var(--surface-muted);
      padding: 18px 20px;
    }

    .callout--results {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .result-placeholder {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .result-group {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    .result-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 16px;
      background: var(--surface);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .result-item[data-tone="success"] .value {
      color: var(--success);
    }

    .result-item[data-tone="info"] .value {
      color: var(--info);
    }

    .result-item .label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .result-item .value {
      font-size: 1.3rem;
      font-weight: 600;
    }

    .result-item .meta {
      font-size: 0.875rem;
      color: var(--text-muted);
    }

    .result-warning {
      border-radius: 10px;
      padding: 12px 14px;
      background: var(--accent-soft);
      color: var(--accent-hover);
      font-size: 0.9rem;
    }

    .button {
      appearance: none;
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 0 22px;
      height: 44px;
      line-height: 1;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform var(--transition), box-shadow var(--transition), background var(--transition), color var(--transition);
      background: var(--surface-muted);
      color: var(--text);
    }

    .workflow-actions {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: stretch;
    }

    .workflow-actions__primary {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
    }

    .workflow-actions__primary .button {
      flex: 1 1 220px;
      height: 52px;
      font-size: 1rem;
      border-radius: 14px;
    }

    #selectBtn.button--primary {
      box-shadow: 0 22px 40px -26px rgba(37, 99, 235, 0.75);
    }

    #uploadBtn {
      background: #111827;
      color: #fff;
    }

    #uploadBtn:hover:not(:disabled) {
      background: #0f172a;
    }

    #uploadBtn:disabled {
      background: rgba(15, 23, 42, 0.28);
      color: rgba(255, 255, 255, 0.7);
    }

    .workflow-actions__secondary {
      display: flex;
      justify-content: flex-end;
    }

    #debugBtn {
      border-color: var(--border);
      background: rgba(15, 23, 42, 0.05);
      color: var(--text-muted);
      padding: 0 18px;
      height: 44px;
    }

    #debugBtn:hover:not(:disabled),
    #debugBtn:focus-visible {
      background: rgba(15, 23, 42, 0.12);
      border-color: rgba(15, 23, 42, 0.28);
      color: var(--text);
    }

    #debugBtn:disabled {
      opacity: 0.5;
    }

    @media (max-width: 600px) {
      .workflow-actions__primary {
        flex-direction: column;
      }

      .workflow-actions__secondary {
        justify-content: center;
      }
    }

    .button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px -18px rgba(15, 23, 42, 0.55);
    }

    .button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
      box-shadow: none;
    }

    .button--primary {
      background: var(--accent);
      color: #fff;
    }

    .button--primary:hover:not(:disabled) {
      background: var(--accent-hover);
    }

    .button--ghost {
      background: transparent;
      border-color: var(--border-strong);
    }

    .button--ghost:hover:not(:disabled) {
      color: var(--accent);
      border-color: var(--accent);
    }

    .select-wrapper {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 220px;
    }

    .select-label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    select {
      width: 100%;
      height: 44px;
      padding: 0 14px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--surface-muted);
      color: var(--text);
      font-size: 0.95rem;
      transition: border-color var(--transition), box-shadow var(--transition);
    }

    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.25);
      outline: none;
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .model-status {
      display: grid;
      gap: 10px;
      margin-top: 10px;
    }

    .model-status__item {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface-muted);
      color: inherit;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 12px 14px;
      width: 100%;
      text-align: left;
      font: inherit;
      cursor: pointer;
      transition: border-color var(--transition), background var(--transition), box-shadow var(--transition);
    }

    .model-status__item:hover,
    .model-status__item:focus-visible {
      border-color: var(--accent);
      box-shadow: 0 8px 20px -18px rgba(15, 23, 42, 0.45);
      outline: none;
    }

    .model-status__item[aria-checked="true"] {
      border-color: var(--accent);
      background: rgba(37, 99, 235, 0.08);
    }

    .model-status__main {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 600;
    }

    .model-status__meta {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .status-indicator {
      width: 11px;
      height: 11px;
      border-radius: 50%;
      background: var(--border-strong);
      box-shadow: 0 0 0 3px rgba(148, 163, 184, 0.25);
    }

    .status-indicator--online {
      background: #16a34a;
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.25);
    }

    .status-indicator--offline {
      background: #dc2626;
      box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.25);
    }

    .model-status__placeholder {
      padding: 14px 16px;
      border: 1px dashed var(--border);
      border-radius: 12px;
      background: var(--surface-muted);
      color: var(--text-muted);
      font-size: 0.9rem;
      text-align: center;
    }

    .model-status__placeholder--error {
      border-color: rgba(248, 113, 113, 0.6);
      color: #b91c1c;
    }

    .model-status__meta strong {
      font-weight: 600;
      color: var(--text);
    }

    .model-status__item[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
      pointer-events: none;
    }

    .model-status__placeholder--error {
      border-color: rgba(248, 113, 113, 0.6);
      color: #b91c1c;
    }

    input[type="file"] {
      display: none;
    }

    input[type="password"] {
      width: 100%;
      height: 44px;
      padding: 0 14px;
      border: 1px solid var(--border-strong);
      border-radius: 10px;
      background: var(--surface-muted);
      font-size: 1rem;
      transition: border-color var(--transition), box-shadow var(--transition);
    }

    input[type="password"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.25);
      outline: none;
    }

    .status-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .status-block {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 18px;
      background: var(--surface-muted);
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 122px;
    }

    .status-block h3 {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .status-copy {
      font-size: 0.95rem;
      color: var(--text);
      white-space: pre-line;
    }

    .surface--logs {
      margin-top: 28px;
    }

    #logsContent {
      border: 1px solid var(--border);
      border-radius: calc(var(--radius) - 6px);
      padding: 16px;
      background: var(--surface-muted);
      font-family: 'JetBrains Mono', 'Fira Code', 'SFMono-Regular', Menlo, monospace;
      font-size: 0.85rem;
      color: var(--text-muted);
      white-space: pre-wrap;
      overflow-y: auto;
      max-height: 280px;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      background: rgba(15, 23, 42, 0.55);
      z-index: 10;
    }

    .modal__content {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      width: min(420px, 100%);
      padding: 32px 30px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      text-align: center;
    }

    .modal__title {
      font-size: 1.4rem;
    }

    .modal__hint {
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .modal__actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      margin-top: 10px;
    }

    .modal__actions .button {
      width: 100%;
      height: 48px;
      border-radius: 12px;
      font-size: 1rem;
    }

    .modal__actions .button--ghost {
      border-color: transparent;
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-muted);
    }

    .modal__actions .button--ghost:hover {
      color: var(--text);
      background: rgba(148, 163, 184, 0.2);
    }

    @media (max-width: 540px) {
      .page {
        padding: 0 18px;
      }

      .surface {
        padding: 20px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .button {
        transition: none;
      }

      select:focus,
      input[type="password"]:focus {
        box-shadow: none;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="page-header">
      <h1>HAL Web Demo</h1>
      <p class="page-subtitle">Upload or debug a video and review inference results in real time.</p>
    </header>

    <div class="modal" id="apiKeyModel" role="dialog" aria-modal="true" aria-labelledby="apiKeyModalTitle">
      <div class="modal__content" id="apiKeyModelContent">
        <h2 class="modal__title" id="apiKeyModalTitle">Enter API Key</h2>
        <p class="modal__hint">Provide your HAL API key or switch to offline debug mode.</p>
        <input type="password" id="apiKeyInput" placeholder="API Key" aria-label="API Key" />
        <div class="modal__actions">
          <button class="button button--primary" id="submitApiKeyBtn" type="button">Submit</button>
          <button class="button button--ghost" id="offlineModeBtn" type="button">Offline Debug Mode</button>
        </div>
      </div>
    </div>

    <main class="layout" aria-live="polite">
      <section class="surface" id="resultsPanel" aria-labelledby="videoPanelTitle">
        <div class="surface__header">
          <h2 id="videoPanelTitle">Live Video Preview</h2>
          <p class="surface__description">Video playback updates automatically when inference data arrives.</p>
        </div>
        <div id="videoContainer" class="media">
          <video id="videoPreview" autoplay muted playsinline webkit-playsinline></video>
          <canvas id="keypointsCanvas"></canvas>
        </div>
        <div id="inferenceResults" class="callout callout--results">
          <div class="result-placeholder">No inference data available.</div>
        </div>
      </section>

      <section class="surface surface--workflow" aria-labelledby="workflowTitle">
        <div class="surface__header">
          <h2 id="workflowTitle">Workflow</h2>
          <p class="surface__description">Select a video, run a debug pass, or push to AWS for full inference.</p>
        </div>
        <div class="workflow-actions">
          <div class="workflow-actions__primary">
            <button id="selectBtn" class="button button--primary" type="button">Select Video</button>
            <button id="uploadBtn" class="button button--primary" type="button" disabled>Upload to AWS</button>
          </div>
          <div class="workflow-actions__secondary">
            <button id="debugBtn" class="button button--ghost" type="button" disabled>Debug Test</button>
          </div>
          <input type="file" id="fileSelectInput" accept="video/*" />
        </div>
        <label class="select-wrapper visually-hidden">
          <span class="select-label">API Version</span>
          <select id="versionSelect" aria-describedby="modelStatusList"></select>
        </label>
        <div id="modelStatusList" class="model-status" aria-live="polite" role="radiogroup" aria-label="Available models"></div>
        <div class="status-grid">
          <div class="status-block" id="uploadPanel">
            <h3>Upload</h3>
            <p id="uploadMessage" class="status-copy">Waiting for video...</p>
          </div>
          <div class="status-block" id="statusPanel">
            <h3>Status</h3>
            <p id="statusMessage" class="status-copy">No updates yet.</p>
          </div>
          <div class="status-block" id="downloadPanel">
            <h3>Download</h3>
            <p id="downloadMessage" class="status-copy">Waiting...</p>
          </div>
        </div>
      </section>
    </main>

    <section class="surface surface--logs" id="apiLogs" aria-labelledby="logsTitle">
      <div class="surface__header">
        <h2 id="logsTitle">Live API Logs</h2>
      </div>
      <pre id="logsContent">Logs will appear here...</pre>
    </section>
  </div>

  <script>
    /* ------------------------------------------------------------------------
       App State & Configuration
    ------------------------------------------------------------------------ */
    const API_BASE_URL = 'https://ue7v1pazxb.execute-api.us-west-2.amazonaws.com';
    const OFFLINE_MODE_KEY = '__HAL_OFFLINE_DEBUG__';
    const DEFAULT_ENDPOINTS = [
      { version: '0.5.1', endpoint_status: 'Offline', num_endpoint_instances: 0 },
      { version: '0.4.3', endpoint_status: 'Offline', num_endpoint_instances: 0 },
      { version: '0.4.2', endpoint_status: 'Offline', num_endpoint_instances: 0 },
      { version: '0.3.3', endpoint_status: 'Offline', num_endpoint_instances: 0 }
    ];

    let API_KEY = null;
    let selectedVideoBlob = null;
    let poseData = {};
    let poseKeys = [];
    let frameRate = 30;
    let isRenderLoopAttached = false;
    let lastDrawnFrame = null;
    let poseKeysMissingLogged = false;
    let poseFrameMissingLogged = false;
    let availableModels = [];

    /* ------------------------------------------------------------------------
       DOM References
    ------------------------------------------------------------------------ */
    const apiKeyModel = document.getElementById('apiKeyModel');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const submitApiKeyBtn = document.getElementById('submitApiKeyBtn');
    const offlineModeBtn = document.getElementById('offlineModeBtn');

    const videoPreview = document.getElementById('videoPreview');
    const keypointsCanvas = document.getElementById('keypointsCanvas');

    const fileSelectInput = document.getElementById('fileSelectInput');

    const selectBtn = document.getElementById('selectBtn');
    const debugBtn = document.getElementById('debugBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const versionSelect = document.getElementById('versionSelect');

    const uploadMessage = document.getElementById('uploadMessage');
    const statusMessage = document.getElementById('statusMessage');
    const downloadMessage = document.getElementById('downloadMessage');
    const inferenceResults = document.getElementById('inferenceResults');
    const logsContent = document.getElementById('logsContent');
    const modelStatusList = document.getElementById('modelStatusList');

    /* ------------------------------------------------------------------------
       UI Helpers
    ------------------------------------------------------------------------ */
    function showInferencePlaceholder(message = 'No inference data yet.') {
      inferenceResults.innerHTML = `<div class="result-placeholder">${message}</div>`;
    }

    function setActionAvailability({ select, debug, upload } = {}) {
      if (typeof select === 'boolean') {
        selectBtn.disabled = !select;
      }
      if (typeof debug === 'boolean') {
        debugBtn.disabled = !debug;
      }
      if (typeof upload === 'boolean') {
        uploadBtn.disabled = !upload;
      }
    }

    function refreshActionAvailability() {
      setActionAvailability({
        select: true,
        debug: Boolean(selectedVideoBlob),
        upload: Boolean(selectedVideoBlob) && API_KEY !== OFFLINE_MODE_KEY
      });
    }

    function logToAPI(message) {
      const timestamp = new Date().toLocaleTimeString();
      logsContent.textContent += `[${timestamp}] ${message}\n`;
      logsContent.scrollTop = logsContent.scrollHeight;
      console.log(`[${timestamp}] ${message}`);
    }

    function populateVersionSelect(endpoints, { offline = false } = {}) {
      if (!Array.isArray(endpoints) || endpoints.length === 0) {
        availableModels = [];
        versionSelect.innerHTML = '';
        versionSelect.disabled = true;
        renderModelStatus([], { offline });
        return null;
      }

      availableModels = endpoints.map((endpoint) => ({
        version: endpoint.version,
        status: offline ? 'Offline' : endpoint.endpoint_status || 'Unknown',
        instances: offline ? 0 : Number(endpoint.num_endpoint_instances) || 0,
        endpointName: endpoint.endpoint_name || '',
        offline
      }));

      versionSelect.innerHTML = '';
      availableModels.forEach((model) => {
        const option = document.createElement('option');
        option.value = model.version;
        option.textContent = model.version;
        versionSelect.appendChild(option);
      });

      versionSelect.disabled = false;
      const preferred = availableModels.find((model) => !model.offline && model.status === 'InService' && model.instances > 0) || availableModels[0];

      if (preferred) {
        setSelectedVersion(preferred.version, { programmatic: true });
        return preferred.version;
      }

      renderModelStatus(availableModels, { offline });
      return null;
    }

    function renderModelStatus(models, { offline = false, loading = false } = {}) {
      if (loading) {
        modelStatusList.innerHTML = '<div class="model-status__placeholder">Loading available models...</div>';
        return;
      }

      if (!models.length) {
        modelStatusList.innerHTML = '<div class="model-status__placeholder">No models available.</div>';
        return;
      }

      const currentValue = versionSelect.value;
      const offlineMode = offline || models.every((model) => model.offline);

      modelStatusList.innerHTML = models.map((model) => {
        const isSelected = model.version === currentValue;
        const hasInstances = !offlineMode && model.status === 'InService' && model.instances > 0;
        const indicatorClass = hasInstances ? 'status-indicator status-indicator--online' : 'status-indicator status-indicator--offline';
        const metaLabel = offlineMode
          ? 'Debug mode only'
          : hasInstances
            ? formatInstanceLabel(model.instances)
            : 'No active instances';
        const statusSuffix = offlineMode ? '' : model.status ? ` · ${model.status}` : '';
        const ariaStatus = offlineMode ? 'offline mode' : (model.status || 'status unknown');
        const ariaMeta = offlineMode
          ? 'Debug mode only'
          : hasInstances
            ? `${model.instances} active ${model.instances === 1 ? 'instance' : 'instances'}`
            : 'No active instances';
        const ariaLabel = `${model.version}: ${ariaMeta}, ${ariaStatus}`;

        return `
          <button
            type="button"
            class="model-status__item"
            data-version="${model.version}"
            role="radio"
            aria-checked="${isSelected}"
            tabindex="${isSelected ? '0' : '-1'}"
            aria-label="${ariaLabel}"
          >
            <span class="model-status__main">
              <span class="${indicatorClass}" aria-hidden="true"></span>
              <span>${model.version}</span>
            </span>
            <span class="model-status__meta">${metaLabel}${statusSuffix}</span>
          </button>
        `.trim();
      }).join('');
    }

    function formatInstanceLabel(count) {
      if (!Number.isFinite(count) || count <= 0) {
        return 'No active instances';
      }
      return `${count} active ${count === 1 ? 'instance' : 'instances'}`;
    }

    function setSelectedVersion(version, { programmatic = false } = {}) {
      if (!version || !availableModels.length) {
        return;
      }

      const optionExists = Array.from(versionSelect.options).some((option) => option.value === version);
      if (!optionExists) {
        return;
      }

      const previousValue = versionSelect.value;
      if (previousValue !== version) {
        versionSelect.value = version;
      }

      handleVersionChange();

      if (!programmatic) {
        requestAnimationFrame(() => {
          const nextItem = modelStatusList.querySelector(`.model-status__item[data-version="${version}"]`);
          if (nextItem) {
            nextItem.focus();
          }
        });
      }
    }

    showInferencePlaceholder('No inference data available.');
    setActionAvailability({ select: false, debug: false, upload: false });
    populateVersionSelect(DEFAULT_ENDPOINTS, { offline: true });

    /* ------------------------------------------------------------------------
       Event Wiring
    ------------------------------------------------------------------------ */
    submitApiKeyBtn.addEventListener('click', handleApiKeySubmit);
    offlineModeBtn.addEventListener('click', enableOfflineMode);
    selectBtn.addEventListener('click', () => fileSelectInput.click());
    fileSelectInput.addEventListener('change', handleFileInputChange);
    uploadBtn.addEventListener('click', handleUploadClick);
    debugBtn.addEventListener('click', handleDebugClick);
    versionSelect.addEventListener('change', () => setSelectedVersion(versionSelect.value, { programmatic: true }));
    modelStatusList.addEventListener('click', handleModelSelectionClick);
    modelStatusList.addEventListener('keydown', handleModelStatusKeydown);

    /* ------------------------------------------------------------------------
       Event Handlers
    ------------------------------------------------------------------------ */
    function handleApiKeySubmit() {
      const enteredKey = apiKeyInput.value.trim();
      if (!enteredKey) {
        alert('API key is required to proceed.');
        return;
      }

      API_KEY = enteredKey;
      apiKeyModel.style.display = 'none';
      initializeApp(false);
    }

    function enableOfflineMode() {
      API_KEY = OFFLINE_MODE_KEY;
      apiKeyModel.style.display = 'none';
      initializeApp(true);
    }

    function handleFileInputChange(event) {
      const [file] = event.target.files || [];
      if (file) {
        handleFileSelection(file);
        fileSelectInput.value = '';
      }
    }

    function handleModelSelectionClick(event) {
      const target = event.target.closest('.model-status__item');
      if (!target || !modelStatusList.contains(target) || target.hasAttribute('disabled')) {
        return;
      }

      const { version } = target.dataset;
      if (version) {
        setSelectedVersion(version);
      }
    }

    function handleModelStatusKeydown(event) {
      if (!event.target.classList.contains('model-status__item')) {
        return;
      }

      const actionableKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
      if (!actionableKeys.includes(event.key)) {
        return;
      }

      const items = Array.from(modelStatusList.querySelectorAll('.model-status__item'));
      if (items.length === 0) {
        return;
      }

      const currentIndex = items.findIndex((item) => item.dataset.version === event.target.dataset.version);
      if (currentIndex === -1) {
        return;
      }

      event.preventDefault();

      let nextIndex = currentIndex;
      switch (event.key) {
        case 'ArrowUp':
        case 'ArrowLeft':
          nextIndex = currentIndex === 0 ? items.length - 1 : currentIndex - 1;
          break;
        case 'ArrowDown':
        case 'ArrowRight':
          nextIndex = currentIndex === items.length - 1 ? 0 : currentIndex + 1;
          break;
        case 'Home':
          nextIndex = 0;
          break;
        case 'End':
          nextIndex = items.length - 1;
          break;
        default:
          break;
      }

      const nextItem = items[nextIndex];
      if (nextItem && nextItem.dataset.version) {
        setSelectedVersion(nextItem.dataset.version);
      }
    }

    function handleVersionChange() {
      if (!availableModels.length) {
        return;
      }
      const offlineMode = API_KEY === OFFLINE_MODE_KEY || availableModels.every((model) => model.offline);
      renderModelStatus(availableModels, { offline: offlineMode });
    }

    async function handleUploadClick() {
      if (!selectedVideoBlob) {
        uploadMessage.textContent = 'No video selected!';
        logToAPI('Upload attempted without a video.');
        return;
      }

      setActionAvailability({ select: false, debug: false, upload: false });
      uploadMessage.textContent = 'Starting upload process...';
      statusMessage.textContent = 'Upload initiated.';
      downloadMessage.textContent = 'Waiting for processing...';
      showInferencePlaceholder('Waiting for inference results...');
      logToAPI('Upload process started.');

      const timestamp = new Date().toISOString().replace(/[-:.TZ]/g, '');
      const videoName = `web_upload_${timestamp}.mp4`;
      logToAPI(`Uploading video as: ${videoName}`);

      try {
        const uploadEndpoint = `${API_BASE_URL}/upload/dev/${encodeURIComponent(videoName)}`;
        logToAPI(`Requesting upload URL: ${uploadEndpoint}`);

        const uploadResponse = await fetch(uploadEndpoint, {
          method: 'GET',
          headers: {
            'x-api-version': versionSelect.value,
            'x-api-key': API_KEY
          }
        });

        if (!uploadResponse.ok) {
          throw new Error(`Upload request failed: ${uploadResponse.status} ${uploadResponse.statusText}`);
        }

        const uploadData = await uploadResponse.json();
        const { guid, presigned_url: presignedUrl } = uploadData;
        logToAPI(`Upload details: GUID=${guid}, URL=${presignedUrl}`);
        uploadMessage.textContent = `GUID: ${guid} — Preparing upload...`;

        uploadMessage.textContent += '\nUploading video...';
        logToAPI(`Uploading video to: ${presignedUrl}`);
        const putResponse = await fetch(presignedUrl, {
          method: 'PUT',
          headers: { 'Content-Type': 'video/mp4' },
          body: selectedVideoBlob
        });

        if (!putResponse.ok) {
          throw new Error(`Upload failed: ${putResponse.status} ${putResponse.statusText}`);
        }

        uploadMessage.textContent += '\nUpload successful!';
        logToAPI('Video uploaded to AWS.');

        statusMessage.textContent = 'Video uploaded. Processing started.';
        logToAPI('Starting status polling.');
        pollStatus(guid);
      } catch (error) {
        uploadMessage.textContent += `\nError: ${error.message}`;
        logToAPI(`Upload error: ${error.message}`);
        refreshActionAvailability();
      }
    }

    function handleDebugClick() {
      if (!selectedVideoBlob) {
        alert('Please select a video first.');
        return;
      }

      setActionAvailability({ select: false, debug: false, upload: false });
      logToAPI('Debug test triggered.');
      uploadMessage.textContent = 'Debug test initiated. Skipping upload...';
      statusMessage.textContent = 'Simulating processing...';
      downloadMessage.textContent = 'Fetching debug results...';
      showInferencePlaceholder('Waiting for debug results...');

      const debugJson = {
        version: versionSelect.value,
        status: 'success',
        message: 'Debug inference completed successfully',
        warnings: [],
        fps: 30.0,
        total_frames: 20,
        subjects: [
          {
            subject_id: 0,
            track_id: 1,
            left_prediction: 3,
            left_confidence: 0.74,
            right_prediction: 2,
            right_confidence: 0.78,
            track_length: 20,
            pose_keys: [
              'Box_X1','Box_Y1','Box_X2','Box_Y2',
              'X_left_shoulder','Y_left_shoulder',
              'X_right_shoulder','Y_right_shoulder',
              'X_left_elbow','Y_left_elbow',
              'X_right_elbow','Y_right_elbow',
              'X_left_wrist','Y_left_wrist',
              'X_right_wrist','Y_right_wrist'
            ],
            pose_df: {
              '0': [88, 212, 276, 701, 234, 299, 163, 290, 226, 377, 127, 336, 143, 409, 102, 351],
              '1': [87, 211, 276, 700, 233, 298, 162, 290, 226, 375, 126, 337, 143, 407, 102, 350],
              '2': [87, 210, 275, 699, 231, 297, 161, 290, 226, 374, 125, 337, 142, 406, 101, 350],
              '3': [86, 210, 274, 698, 230, 296, 160, 289, 225, 372, 124, 338, 142, 404, 101, 349],
              '4': [86, 209, 274, 697, 228, 295, 159, 289, 225, 371, 123, 338, 142, 403, 101, 348],
              '5': [86, 209, 273, 696, 227, 295, 158, 289, 224, 370, 123, 338, 142, 402, 100, 348],
              '6': [86, 208, 273, 696, 227, 294, 157, 289, 224, 370, 122, 339, 142, 401, 100, 347],
              '7': [86, 208, 272, 695, 226, 294, 157, 289, 223, 370, 122, 339, 142, 401, 100, 347],
              '8': [86, 209, 272, 694, 225, 294, 156, 289, 223, 369, 122, 340, 142, 400, 100, 347],
              '9': [87, 209, 271, 694, 225, 294, 156, 290, 223, 369, 123, 340, 142, 400, 100, 346],
              '10': [87, 209, 271, 694, 224, 294, 156, 290, 222, 369, 123, 341, 142, 400, 100, 346],
              '11': [88, 210, 270, 693, 223, 294, 156, 290, 222, 369, 123, 341, 142, 399, 100, 346],
              '12': [88, 211, 270, 693, 222, 295, 156, 291, 221, 369, 123, 341, 142, 399, 101, 346],
              '13': [88, 212, 269, 692, 221, 295, 156, 292, 221, 369, 124, 342, 141, 399, 101, 345],
              '14': [87, 212, 268, 691, 220, 295, 156, 292, 221, 368, 124, 343, 141, 399, 101, 345],
              '15': [87, 213, 267, 690, 219, 294, 155, 293, 220, 368, 124, 344, 141, 399, 102, 345],
              '16': [86, 213, 266, 688, 218, 294, 155, 293, 220, 368, 124, 345, 141, 399, 102, 346],
              '17': [86, 213, 265, 686, 218, 294, 154, 293, 220, 368, 125, 346, 141, 399, 103, 346],
              '18': [85, 213, 264, 684, 217, 293, 154, 293, 220, 367, 125, 347, 141, 400, 103, 346],
              '19': [85, 213, 264, 683, 216, 293, 154, 293, 220, 367, 125, 347, 141, 400, 104, 347]
            }
          }
        ]
      };

      setTimeout(() => {
        applyInferenceResult(debugJson, 'Debug');
      }, 1000);
    }

    /* ------------------------------------------------------------------------
       Initialization & API helpers
    ------------------------------------------------------------------------ */
    function initializeApp(isOffline) {
      selectedVideoBlob = null;
      poseData = {};
      poseKeys = [];
      frameRate = 30;
      availableModels = [];

      videoPreview.pause();
      videoPreview.removeAttribute('src');
      videoPreview.load();
      keypointsCanvas.getContext('2d').clearRect(0, 0, keypointsCanvas.width, keypointsCanvas.height);

      refreshActionAvailability();

      if (isOffline) {
        populateVersionSelect(DEFAULT_ENDPOINTS, { offline: true });
        uploadMessage.textContent = 'Offline debug mode. Select a video to test locally.';
        logToAPI('Offline debug mode enabled. Uploads to AWS are disabled.');
        versionSelect.disabled = false;
      } else {
        versionSelect.disabled = true;
        versionSelect.innerHTML = '';
        renderModelStatus([], { loading: true });
        uploadMessage.textContent = 'API key saved. Select a video to begin.';
        logToAPI('API key set. Fetching available versions...');
        fetchHealthStatus();
      }

      statusMessage.textContent = 'No updates yet.';
      downloadMessage.textContent = 'Waiting...';
      showInferencePlaceholder('Select a video to get started.');
    }

    async function fetchHealthStatus() {
      if (API_KEY === OFFLINE_MODE_KEY) {
        uploadMessage.textContent = 'Offline mode: uploads are disabled. Switch to online mode with an API key to upload.';
        logToAPI('Upload blocked: offline mode active.');
        return;
      }

      const healthEndpoint = `${API_BASE_URL}/health`;
      renderModelStatus([], { loading: true });
      versionSelect.disabled = true;

      try {
        const res = await fetch(healthEndpoint, {
          headers: { 'x-api-key': API_KEY }
        });

        if (!res.ok) {
          throw new Error(`Health request failed: ${res.status} ${res.statusText}`);
        }

        const healthData = await res.json();
        const endpoints = Array.isArray(healthData.endpoints) ? healthData.endpoints : [];
        const inService = endpoints.filter((endpoint) => endpoint.endpoint_status === 'InService');
        const candidates = inService.length > 0 ? inService : endpoints;

        if (candidates.length === 0) {
          availableModels = [];
          versionSelect.innerHTML = '';
          renderModelStatus([], { offline: false });
          versionSelect.disabled = true;
          logToAPI('Health check returned no available endpoints.');
          return;
        }

        candidates.sort((a, b) => b.version.localeCompare(a.version, undefined, { numeric: true, sensitivity: 'base' }));
        const defaultVersion = populateVersionSelect(candidates, { offline: false });
        const versionsList = availableModels.map((model) => model.version).join(', ');
        const message = defaultVersion
          ? `Available versions: ${versionsList}. Defaulting to ${defaultVersion}.`
          : `Available versions: ${versionsList}.`;
        logToAPI(message);
      } catch (error) {
        logToAPI(`Health check error: ${error.message}`);
        renderModelStatus(availableModels, { offline: API_KEY === OFFLINE_MODE_KEY });
        versionSelect.disabled = availableModels.length === 0;
      }
    }

    function handleFileSelection(file) {
      selectedVideoBlob = file;
      uploadMessage.textContent = `Selected: ${file.name} (${file.size} bytes). Ready for upload or debug.`;
      statusMessage.textContent = 'Video file selected.';
      downloadMessage.textContent = 'Waiting...';
      showInferencePlaceholder('Awaiting inference results.');
      logToAPI(`Video selected: ${file.name}`);

      const videoURL = URL.createObjectURL(file);
      videoPreview.srcObject = null;
      videoPreview.src = videoURL;
      videoPreview.controls = true;
      videoPreview.onloadedmetadata = () => {
        keypointsCanvas.width = videoPreview.videoWidth;
        keypointsCanvas.height = videoPreview.videoHeight;
        logToAPI(`Video metadata loaded: ${videoPreview.videoWidth}x${videoPreview.videoHeight}, duration ${videoPreview.duration.toFixed(2)}s.`);
      };

      refreshActionAvailability();

      if (API_KEY === OFFLINE_MODE_KEY) {
        uploadMessage.textContent += '\nOffline mode: Upload button remains disabled.';
      }
    }

    /* ------------------------------------------------------------------------
       Upload & Polling Flow
    ------------------------------------------------------------------------ */
    function pollStatus(guid) {
      let pollCount = 0;
      const maxPolls = 60;
      const intervalTime = 30000;
      logToAPI(`Polling status for GUID: ${guid}`);

      const pollTimer = setInterval(async () => {
        pollCount += 1;
        logToAPI(`Polling attempt #${pollCount}`);
        statusMessage.textContent = `Status check #${pollCount}...`;

        try {
          const statusEndpoint = `${API_BASE_URL}/status/dev/${encodeURIComponent(guid)}`;
          const statusRes = await fetch(statusEndpoint, {
            method: 'GET',
            headers: { 'x-api-key': API_KEY }
          });

          if (!statusRes.ok) {
            throw new Error(`Status error: ${statusRes.status} ${statusRes.statusText}`);
          }

          const statusData = await statusRes.json();
          logToAPI(`Status: ${JSON.stringify(statusData)}`);
          statusMessage.textContent = `Current Status: ${statusData.status}`;

          if (statusData.status === 'done') {
            clearInterval(pollTimer);
            statusMessage.textContent += ' — Processing complete.';
            downloadMessage.textContent = 'Fetching final results...';
            logToAPI('Processing complete. Fetching results.');
            fetchFinalResults(guid);
          } else if (pollCount >= maxPolls) {
            clearInterval(pollTimer);
            statusMessage.textContent += ' — Max polling attempts reached.';
            downloadMessage.textContent = 'Processing timed out.';
            logToAPI('Max polling reached.');
            refreshActionAvailability();
          }
        } catch (error) {
          statusMessage.textContent = `Error: ${error.message}`;
          logToAPI(`Polling error: ${error.message}`);
          clearInterval(pollTimer);
          refreshActionAvailability();
        }
      }, intervalTime);
    }

    async function fetchFinalResults(guid) {
      try {
        const downloadEndpoint = `${API_BASE_URL}/download/dev/${encodeURIComponent(guid)}`;
        logToAPI(`Fetching download URL: ${downloadEndpoint}`);

        const downloadRes = await fetch(downloadEndpoint, {
          method: 'GET',
          headers: { 'x-api-key': API_KEY }
        });

        if (!downloadRes.ok) {
          throw new Error(`Download request failed: ${downloadRes.status} ${downloadRes.statusText}`);
        }

        const downloadData = await downloadRes.json();
        const finalUrl = downloadData.presigned_url;
        logToAPI(`Final download URL: ${finalUrl}`);
        downloadMessage.textContent = 'Results URL received. Fetching predictions...';

        const finalRes = await fetch(finalUrl);
        if (!finalRes.ok) {
          throw new Error(`Final JSON fetch failed: ${finalRes.status} ${finalRes.statusText}`);
        }

        const finalJson = await finalRes.json();
        logToAPI(`Final payload received. version=${finalJson.version || 'n/a'}, status=${finalJson.status || 'n/a'}`);
        applyInferenceResult(finalJson, 'Inference');
      } catch (error) {
        downloadMessage.textContent = `Error: ${error.message}`;
        logToAPI(`Download error: ${error.message}`);
        refreshActionAvailability();
      }
    }

    /* ------------------------------------------------------------------------
       Result Application & Rendering
    ------------------------------------------------------------------------ */
    function applyInferenceResult(finalJson, contextLabel) {
      const label = contextLabel || 'Inference';

      if (!finalJson || typeof finalJson !== 'object') {
        downloadMessage.textContent = `${label} results unavailable.`;
        logToAPI(`${label} results missing or invalid.`);
        refreshActionAvailability();
        return;
      }

      const subject = Array.isArray(finalJson.subjects) && finalJson.subjects.length > 0
        ? finalJson.subjects[0]
        : null;

      if (!subject) {
        downloadMessage.textContent = `${label} results contain no subjects.`;
        logToAPI(`${label} results missing subject data.`);
        refreshActionAvailability();
        return;
      }

      poseData = subject.pose_df || {};
      poseKeys = subject.pose_keys || [];
      frameRate = finalJson.fps || 30;

      lastDrawnFrame = null;
      poseKeysMissingLogged = false;
      poseFrameMissingLogged = false;

      const versionUsed = finalJson.version || versionSelect.value || 'n/a';
      const rightPrediction = subject.right_prediction ?? 'N/A';
      const rightConfidence = subject.right_confidence;
      const leftPrediction = subject.left_prediction ?? 'N/A';
      const leftConfidence = subject.left_confidence;

      const formatConfidence = (value) => (typeof value === 'number' ? `${(value * 100).toFixed(0)}%` : 'N/A');

      downloadMessage.textContent = `${label} results ready (version ${versionUsed}).\nRight: HAL=${rightPrediction} (${formatConfidence(rightConfidence)})\nLeft: HAL=${leftPrediction} (${formatConfidence(leftConfidence)})`;

      if (Array.isArray(finalJson.warnings) && finalJson.warnings.length > 0) {
        downloadMessage.textContent += `\nWarnings: ${finalJson.warnings.join(' | ')}`;
      }

      let resultMarkup = `
        <div class="result-group" role="list">
          <div class="result-item" data-tone="success" role="listitem">
            <span class="label">Right Prediction</span>
            <span class="value">${rightPrediction}</span>
            <span class="meta">Confidence ${formatConfidence(rightConfidence)}</span>
          </div>
          <div class="result-item" data-tone="info" role="listitem">
            <span class="label">Left Prediction</span>
            <span class="value">${leftPrediction}</span>
            <span class="meta">Confidence ${formatConfidence(leftConfidence)}</span>
          </div>
        </div>
      `;

      if (Array.isArray(finalJson.warnings) && finalJson.warnings.length > 0) {
        resultMarkup += `<div class="result-warning">${finalJson.warnings.join(' • ')}</div>`;
      }

      inferenceResults.innerHTML = resultMarkup;

      const subjectDescriptor = `subject_id=${subject.subject_id ?? 'n/a'}, track_id=${subject.track_id ?? 'n/a'}`;
      logToAPI(`${label} results displayed (${subjectDescriptor}, version=${versionUsed}).`);

      setupCanvasRendering();

      if (videoPreview.paused || videoPreview.ended) {
        videoPreview.play().catch(() => {});
      }

      refreshActionAvailability();
    }

    function setupCanvasRendering() {
      if (Object.keys(poseData).length === 0) {
        logToAPI('No pose data available for rendering.');
        return;
      }

      if (videoPreview.readyState >= 2) {
        keypointsCanvas.width = videoPreview.videoWidth;
        keypointsCanvas.height = videoPreview.videoHeight;
      }

      if (!isRenderLoopAttached) {
        videoPreview.addEventListener('play', renderLoop);
        videoPreview.addEventListener('seeked', () => {
          requestAnimationFrame(renderLoop);
        });
        isRenderLoopAttached = true;
        logToAPI('Keypoints overlay setup complete. Render loop attached.');
      } else {
        logToAPI('Keypoints overlay data refreshed.');
      }

      if (!videoPreview.paused && !videoPreview.ended) {
        requestAnimationFrame(renderLoop);
      }
    }

    function renderLoop() {
      if (videoPreview.paused || videoPreview.ended) {
        return;
      }
      drawKeypointsOverlay();
      requestAnimationFrame(renderLoop);
    }

    function drawKeypointsOverlay() {
      const currentTime = videoPreview.currentTime;
      const currentFrame = Math.floor(currentTime * frameRate);
      const ctx = keypointsCanvas.getContext('2d');
      ctx.clearRect(0, 0, keypointsCanvas.width, keypointsCanvas.height);

      if (!poseKeys.length) {
        if (!poseKeysMissingLogged) {
          logToAPI('Pose keys unavailable; skipping keypoint overlay.');
          poseKeysMissingLogged = true;
        }
        lastDrawnFrame = currentFrame;
        return;
      }

      const framePayload = poseData[currentFrame] ?? poseData[currentFrame.toString()];
      if (!Array.isArray(framePayload)) {
        if (!poseFrameMissingLogged) {
          logToAPI(`No pose data for frame ${currentFrame}.`);
          poseFrameMissingLogged = true;
        }
        lastDrawnFrame = currentFrame;
        return;
      }

      const frameData = {};
      poseKeys.forEach((keyName, idx) => {
        frameData[keyName] = framePayload[idx];
      });
      poseFrameMissingLogged = false;

      const hasBox = ['Box_X1', 'Box_Y1', 'Box_X2', 'Box_Y2'].every((key) => Number.isFinite(frameData[key]));
      if (hasBox) {
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
        ctx.lineWidth = 3;
        ctx.strokeRect(
          frameData.Box_X1,
          frameData.Box_Y1,
          frameData.Box_X2 - frameData.Box_X1,
          frameData.Box_Y2 - frameData.Box_Y1
        );
      }

      const jointKeys = [
        'X_left_shoulder', 'Y_left_shoulder',
        'X_right_shoulder', 'Y_right_shoulder',
        'X_left_elbow', 'Y_left_elbow',
        'X_right_elbow', 'Y_right_elbow',
        'X_left_wrist', 'Y_left_wrist',
        'X_right_wrist', 'Y_right_wrist'
      ];
      const hasAllJoints = jointKeys.every((key) => Number.isFinite(frameData[key]));

      if (hasAllJoints) {
        ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
        const joints = [
          { x: frameData.X_left_shoulder,  y: frameData.Y_left_shoulder  },
          { x: frameData.X_right_shoulder, y: frameData.Y_right_shoulder },
          { x: frameData.X_left_elbow,     y: frameData.Y_left_elbow     },
          { x: frameData.X_right_elbow,    y: frameData.Y_right_elbow    },
          { x: frameData.X_left_wrist,     y: frameData.Y_left_wrist     },
          { x: frameData.X_right_wrist,    y: frameData.Y_right_wrist    }
        ];

        joints.forEach((joint) => {
          ctx.beginPath();
          ctx.arc(joint.x, joint.y, 7, 0, 2 * Math.PI);
          ctx.fill();
        });

        ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(frameData.X_left_shoulder, frameData.Y_left_shoulder);
        ctx.lineTo(frameData.X_left_elbow, frameData.Y_left_elbow);
        ctx.lineTo(frameData.X_left_wrist, frameData.Y_left_wrist);
        ctx.moveTo(frameData.X_right_shoulder, frameData.Y_right_shoulder);
        ctx.lineTo(frameData.X_right_elbow, frameData.Y_right_elbow);
        ctx.lineTo(frameData.X_right_wrist, frameData.Y_right_wrist);
        ctx.stroke();
      }

      poseKeysMissingLogged = false;

      if (currentFrame !== lastDrawnFrame && currentFrame % 30 === 0) {
        logToAPI(`Keypoints drawn for frame ${currentFrame}.`);
      }
      lastDrawnFrame = currentFrame;
    }
  </script>
</body>
</html>
